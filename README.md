# Интернет-магазин S-Prof

Интернет-магазин задумывался как проработка архитектуры Nest.js (с отсутствием типизации TypeScript поскольку проект 
написан на JavaScript). 

В приложении реализованы: 
- модуль пользователей и авторизация.
- каталог товаров.
- блог интернет-магазина.
- модуль корзины.
- модуль заказов.

Точкой сбора для всех модулей в приложение есть app.js, входная же точка есть - init.js

Проект сделан на основе стэка:
- express.js
- mongoDB / mongoose
- jsonwebtoken
- nodemailer
- session
- jest
- swagger

## Оглавление


## Запуск приложения

Приложение можно запустить с помощью 3х разных вариантов

### Развернуть проект на локальной хост машине

Самый трудоёмкий способ. 

Чтобы развернуть проект на локальной хост машине, необходимо заполнить в корне проекта файл с названием `.env`
Содержание файла `.env` должно состоять в следующих полях:
```javascript
NODE_ENV=<тип работы приложения>, type: string
PORT=<номер порта на хост машине>, type: number
DATABASE=<строка подключения к базе данных>, type: string
JWT_SECRET=<секретное слово>, type: string
JWT_EXPIRES_IN=<время жизни JWT токена>, type: string
JWT_COOKIE_EXPIRES_IN=<время жизни JWT токена в сессии>, type: string
EMAIL_FROM=<электронная почта, с которой будет производится отправка писем>, type: string
SENDGRID_API_KEY=<секретный ключ>, type: string
```

Предварительно нужно зарегистрироваться в сервисе SENDGRID и верифицировать почту отправителя.

Пример заполненного файла `.env`:
```javascript
NODE_ENV=development
PORT=4000
DATABASE=mongodb://localhost:27017/database
JWT_SECRET=jwt-secret-word
JWT_EXPIRES_IN=90d
JWT_COOKIE_EXPIRES_IN=90d
EMAIL_FROM=pestsov.js@gmail.com
SENDGRID_API_KEY=SG1.sadsadsadsadd123234124rqwaf1241234124dax
```

### Развернуть проект с помощью Docker





### Просмотреть проект на Heroku


## Архитектура проекта

Архитектура проекта построена по подобию Nest.js за исключением того, что отсутствуют файлы dto, response и
подобные файлы, которые типизируют приложения, поскольку проект написан на JavaScript. Проект состоит из следующих директорий:

[![image.png](https://i.postimg.cc/yNrMK0jy/image.png)](https://postimg.cc/hJTybzHX)

Где:
- `config` - директория с различными приватными переменными, которые используются в различных сценариях. Для упрощения было описано
2 файла с приватными переменными, при большом и обширном проекте описываются 3 файла: для разработки, для тестирования и для продакшн мода.
- `node_modules` - директория с различными пакетами npm.
- `src` - корневая директория с программным кодом.
  - `core` - сущности, модули или просто функции, которые проходят красной нитью через всё приложение.
  - `documentation` - swagger документация.
  - `modules` - отдельные модули приложения

## Ядро

Насчитывает базовые классы, условия работы сессий, класс по работе с почтой, а также базовый класс обработки ошибок

[![core.png](https://i.postimg.cc/gchC9XZ3/core.png)](https://postimg.cc/t7XSWgDg)

Где:
- `base` - базовый класс который имплементируют все модули. Базовый класс представляет собой расширенную версию CRUD операций. 
  - `base.сontroller` - базовый класс контроллера, в котором сосредоточена логика по работе с req, res. 
  - `base.error` - обработчик ошибок, описывающий все исключения, которые могут быть выброшены при работе с методами базового класса.
  - `base.helper` - класс описывающий методы, которые не относятся к работе с req, res, а также базой данных. Отделяя тем самым логику по работе с сущностями, от базы данных или объектов запроса или ответа.
  - `base.service` - класс описывающий методы, которые работают с базой данных, отделяя таким образом слой работы с базой данных от req, res.
- `email` -
  - `Email` - базовый класс электронной почты, который описывает все методы по работе с письмами.
  - `templates` - директория со всеми шаблонами писем, которые могут быть использованы в приложении.
- `error` - базовый класс обработки ошибок на глобальном уровне приложения.
- `session` - файлы по работе с сессиями.


## Модуль авторизации

Является основополагающим модулем в плане архитектуры файлов внутри модуля.
Авторизация обеспечивает следующие методы:
- регистрация пользователя. 
- логирование пользователя. 
- разлогирование пользователя.
- сброс и восстановления пароля.
- обработчики приватности и доступа только определенных ролей пользователей к определенным ресурсам.

[![Auth-Module.png](https://i.postimg.cc/prQcmjf7/Auth-Module.png)](https://postimg.cc/p5TJ7p1Y)

Где:
- `tests` - директория с тестами каждого отдельного маршрута.
- `auth.controller` - контроллер авторизации, который работает только с объектами запроса и ответа и передающий / принимающий данные в / из сервиса авторизации. 
- `auth.error` - отдельно вынесены ответы и статус коды ошибок.
- `auth.exception` - класс ошибок описывающий исключения для всех маршрутов авторизации.
- `auth.helper` - методы, которые не относятся к объектам запроса, ответа, а также работы с базой данных.
- `auth.middleware` - промежуточные обработчики, которые связаны сущностью авторизации. Проверяют JWT токен пользователя на пути к защищённым маршрутам, а также доступ конкретного пользователя к конкретному маршруту в зависимости от роли пользователя. 
- `auth.router` - маршруты авторизации.
- `auth.router.path` - отдельно вынесенные константы маршрутов.
- `auth.service` - класс работы с базой данных, который использует методы `auth.helper` и принимает / отдаёт данные из / в контроллера.

Отдельно хочется уточнить, что модуль авторизации для своей работы использует сущность пользователей, которую и импортирует напрямую (в TypeScript + Inversify или Nest.js данные сущности можно было бы inject'ить внутрь AuthService).

## Модуль пользователей

Отвечает за работу с сущностью пользователей: 
- Получить всех пользователей.
- Получить пользователя по его ID.
- Изменить профиль пользователя по его ID.
- Удалить профиль пользователя (доступно только админу).
- Деактивация и реактивация профиля пользователя (пользователь, в случае "удаления" аккаунта не удаляет его, а деактивирует, таким образом сохраняя возможность восстановить аккаунт).

[![user-Module.png](https://i.postimg.cc/pXtgPWf4/user-Module.png)](https://postimg.cc/V5D7RcHW)

 Структура модуля пользователей аналогична [модулю авторизации](#модуль-авторизации) за исключением того, что 
у модуля пользователей есть модель - как калька сущности. Модель нужна, чтобы описать схему работы с mongoose и базой данных - MongoDB.

## Модуль каталога

Поскольку база данных для интернет-магазина - MongoDB, следовательно, единицы базы данных является документ, который 
из себя представляет JSON, с возможностью вложенности полей. Также поскольку количество товаров не будет превышать больше 10 000 единиц, 
что при обеспечении индексирования элементов в базе данных, делает быстрый поиск, выборку или сортировку данных.

Исходя из всего выше сказанного каталог может быть организован по следующему принципу: 
1. Есть ключевая сущность продукта, которая состоит из ряда других сущностей.
2. Другие сущности из себя представляют унифицированные кирпичики, которые можно было бы использовать
как элементы выборки.

Пример: Допустим есть электрическая плита, у неё есть её особенности, которые можно засунуть в отдельную сущность - особенности продукта.
всё остальное типизировать: производителя, потребности в коммуникациях, категорию и так далее. Это "можно" и "нужно" типизировать
поскольку между различными типами продуктами могут быть идентичные производители, тип подключения (нет электрического прибора, 
который бы питался от 600 В, а если бы и был, то это был бы лишь третий вид уровня напряжения).

[![catalog-Module.png](https://i.postimg.cc/kXch9xXR/catalog-Module.png)](https://postimg.cc/8j7bmfvT)

Где:
- `catalog` - корневая директория, которая обеспечивает реализацию модуля каталога.
- `electrical_connection` - варианты подключения к коммуникациям.
- `form` - вид оборудования, например: пароконвектоматы, миксеры, тестомесы и т.д.
- `manufacturer` - производитель, может иметь в себе поля: страна производителя, название производителя и т.д.
- `product` - является корневой сущностью, которая в себе завязывает все остальные сущности.
- `type` - Тип оборудования, например: холодильное, тепловое, электромеханическое оборудование и т.д.

## Модуль блога

Построен на системе аналогичной каталогу интернет-магазина, но с другими сущностями. В идеале блог можно обязать WebSocket, чтобы добавление
комментариев можно было бы видеть в реальном времени. 

[![blog-Module.png](https://i.postimg.cc/MGcsyN01/blog-Module.png)](https://postimg.cc/gwWqpMT0)

Где:
- `blog` - корневая директория блога.
- `article` - корневая сущность, которая в себе завязывает все остальные сущности блога.
- `blogCategory` - категории, которые относятся непосредственно к блогу. 
- `comment` - сущность комментариев, может быть несколько у каждой статьи, являются простым текстом.

## Модуль корзины

Каждый пользователь может добавлять, или удалять продукты в своей корзине, таким образом формируя заказ.
Корзина при добавлении или удалении продукта автоматически пересчитывает итоговую стоимость.

Каждый пользователь имеет поле корзины, которая после оформления заказа - обнуляется, таким образом позволяя пользователю 
делать последующие заказы.

[![basket-Module.png](https://i.postimg.cc/zvN0Yfsk/basket-Module.png)](https://postimg.cc/xJsKK9Tk)

Архитектура модуля корзины повторяет общий принцип написание архитектуры модулей. Подробнее про архитектуру модулей смотри: 
[Модуль авторизации](#модуль-авторизации)

## Модуль заказов

Когда пользователь заполнил корзину необходимыми товарами, он может сформировать заказ - сущность, которая является что-то по типу чека.

[![order-Module.png](https://i.postimg.cc/rwHjFg6s/order-Module.png)](https://postimg.cc/18pwvG31)

Архитектура модуля заказов повторяет общий принцип написание архитектуры модулей. Подробнее про архитектуру модулей смотри:
[Модуль авторизации](#модуль-авторизации)
